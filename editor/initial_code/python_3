def checkio(steps):
    
    return ["x+y", 1, -1]

#This part is using only for self-testing
#It's "light" version of the grader
#The hidden expression should be correct (non x/(y-y))
if __name__ == '__main__':
    from fractions import Fraction
    from random import randint

    hidden_expression = "x*y"

    def check_is_right(guess, expression):
        for _ in range(10):
            result_guess = 0
            result_expr = 1
            for __ in range(100):
                x, y = Fraction(randint(-100, 100)), Fraction(randint(-100, 100))
                try:
                    result_expr = eval(expression)
                    result_guess = eval(guess)
                except ZeroDivisionError:
                    continue
                break
            if result_guess != result_expr:
                return False
        return True

    is_win = False
    input_data = []
    for step in range(50):
        guess, x_real, y_real = checkio(input_data)
        x = Fraction(x_real)
        y = Fraction(y_real)
        try:
            result = eval(hidden_expression)
            output = [result.numerator, result.denominator]
        except ZeroDivisionError:
            output = "ZeroDivisionError"
        input_data.append([x_real, y_real, output])
        if check_is_right(guess, hidden_expression):
            print("Right")
            break
    else:
        print("Fail")


def is_win_referee(referee_data):
    if not referee_data["result"]:
        return False
    guess = referee_data['guess']
    expression = referee_data['answer']
    for _ in range(10):
        result_guess = 0
        result_expr = 1
        for __ in range(100):
            x, y = Fraction(randint(-100, 100)), Fraction(randint(-100, 100))
            try:
                result_guess = eval(guess)
                result_expr = eval(expression)
            except ZeroDivisionError:
                continue
            break
        if result_guess != result_expr:
            return False
    return True
